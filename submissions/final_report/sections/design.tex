\section{Design}

\subsection{Hardware}
    The project has been developed for the Raspberry Pi 1 Model B+.
    Some of the relevant hardware onboard includes:
    \begin{itemize}
        \itemsep0em
        \item System-on-Chip: Broadcom BCM2835
        \item CPU: 700MHZ ARM1176JZF-S
        \item GPU: 250MHz Broadcom VideoCore IV
        \item SDRAM: 512MiB, shared with the GPU
        \item Video output: HDMI and DSI
        \item Storage: MicroSDHC slot
        \item 4x USB 2.0 ports
        \item 40 General Purpose Input/Output (GPIO) pins
    \end{itemize}

    \begin{figure}[h]
        \centering
        \includegraphics[width=.8\textwidth]{board.png}
        \caption{Raspberry Pi 1 Model B+}
    \end{figure}

    Development was initially planned for the Raspberry Pi 2 Model B+ simply due
    to its availability, having been received as a gift some years prior.
    However, focus was switched to target the Raspberry Pi 1 Model B+ as a
    result of the difficulties encountered with interacting with the GPU via the
    mailbox interface, with the processing differing slightly and being more
    complex on the 2. The underlying architecture of the 1's BCM2835 chip is,
    however, identical to that of the BCM2836 and BCM2837
    \cite{IdenticalArchitecture}, used by the Raspberry Pi 2 and 3,
    respectively. They only differ in that the 1 uses the ARM1176JZF-S
    processor, as opposed to the quad-core Cortex-A7 and quad-core Cortex-A53
    cluster used by these later boards, in addition to the 512MiB extra
    available to them. Therefore, the choice between specific models for which
    to develop would have made little difference to the outcome of the project,
    and indeed much of the code is transferable. As has been discussed, this
    standard set of hardware was desirable for the project's aims, rendering the
    operating system more widely accessible and for less effort.

    \subsubsection{The Raspberry Pi's boot process}
        The decision to work with the Raspberry Pi in particular, as opposed to
        a more open-ended PC setup, is not only due to the relative lack of
        material available for operating systems development on the ARM
        architecture, but also as a result of the much simpler boot process in
        contrast to other hardware, details of which were found from
        \cite{BootProcess}. Booting is handled almost entirely by the Pi's
        system-on-chip, thus does not require the writing of a custom
        bootloader. Instead, it relies on closed-source proprietary firmware
        programmed into the SoC processor which may not be modified. The
        necessary files can be acquired by either downloading them from
        \cite{Firmware}, or by downloading an existing operating system for the
        Pi and using the files that it provides (since it still requires the
        same firmware).

        During system boot, the ARM CPU does not act as the main CPU, but rather
        as a coprocessor to the VideoCore GPU \cite{PiHackability}. When the
        system is first powered on, the ARM CPU is halted and SDRAM is disabled.
        Control is passed to the GPU, whose responsibility it is to execute the
        bootloader. The bootloader itself is divided into three stages: the
        first stage, stored in ROM on the system-on-chip; the second stage,
        \code{bootcode.bin}, and the third stage, \code{start.elf}. The first
        mounts the FAT32 boot partition on the SD card to enable execution of
        the second-stage bootloader, and then loads this into the L2 cache to
        run it. Control is then passed to the second-stage bootloader, which
        enables SDRAM and loads \code{start.elf} for execution. This final stage
        allows the GPU to start up the CPU. An additional file,
        \code{fixup.dat}, is used to configure the shared SDRAM partition
        between the two processors.  The GPU firmware reads the files
        \code{config.txt} and \code{cmdline.txt} to load the kernel image, then
        releases the CPU from reset and transfers control to it to begin
        executing the kernel. 

        After an operating system is loaded, the code on the GPU is not
        unloaded, but rather runs its own simple operating system, the VideoCore
        Operating System (VCOS) \cite{VideoCore}. This can be used to
        communicate with the services provided by the GPU (for example,
        providing a framebuffer), using the mailbox peripheral and ARM CPU
        interrupts, which the GPU is capable of producing. The GPU is not only
        in charge of graphical functions as, for example, it also controls the
        system timer and audio -- in this way it is therefore more akin to a
        regular PC's BIOS.

\subsection{Development environment}
    The project was developed on various x86 machines running the Linux kernel
    version 4.16 onwards. Since the target environment, the Raspberry Pi 1 Model
    B+, runs on an ARM CPU, the target architecture is therefore different to
    that of the development machines. Therefore, a cross-compiler is required in
    order to compile the code for the target machine. Available on the ARM
    developer website is the GNU Embedded Toolchain \cite{GNUToolchain}.
    Conveniently this suite of tools is available from Arch Linux's package
    manager, Pacman \cite{PacmanEABI}, and this is the version that has been
    used to develop the project.

    \subsubsection{Technical Documentation}
        With no prior experience working in assembly and, in particular, how to
        use ARM assembly in conjunction with the C programming language, it was
        necessary to become better acquainted with this environment, including
        becoming familiar with the instructions available and the calling
        conventions that must be followed (for example, returning the result of
        an assembly procedure call in register 0). This information was gathered
        by reading through both official and unofficial documentation on the ARM
        environment in general and the specifics of working with the Pi. In
        particular, the following were the main resources of technical
        documentation used throughout the project:
        \begin{itemize}
            \itemsep0em 
            \item \textit{ARM1176JZF-S Technical Reference Manual} \cite{TRM}
            \item \textit{ARM Developer Suite Assembler Guide}
                \cite{OnlineARMGuide}
            \item \textit{ARM Cortex-A Series: Programmer's Guide}
                \cite{ProgrammersGuide}
            \item \textit{Broadcom BCM2835 ARM Peripherals Manual} \cite{BCM2835}
        \end{itemize}

        The technical reference manual provides important, in-depth
        architectural information upon which the processor operates, and, for
        example, details concepts such as the programmer's model or interaction
        with the system control coprocessor and the memory management unit. The
        online online guide at \cite{OnlineARMGuide} provides comprehensive
        coverage of the instructions to use when using assembly to program on
        the ARM CPU, and used in conjunction with the programmer's guide
        provides an understanding of when and how to use certain instructions.
        Although not written for the processor used by the Raspberry Pi 1,
        instead written for the CPU used by the 2 and 3, the programmer's guide
        provided further examples of various instructions' use-cases, and its
        utility continued even when focus shifted from the Raspberry Pi 2 to the
        Raspberry Pi 1.

        On the Raspberry Pi are various peripherals, such as the Universal
        Asynchronous Receiver/Transmitter (UART), system/ARM timers, or the
        interrupt controller. Information regarding the layout of their
        registers and the memory addresses from and to which to read and write
        was obtained from the peripherals manual. Since the underlying
        architecture behind the BCM2835 and BCM2836/7 is largely the same, the
        manual was helpful both in development for the Raspberry 1 and 2,
        with the BCM2836 \cite{BCM2836} providing some extra processor specifics
        in the case of the latter.

    \subsubsection{System V ABI}
        Of particular use within GNU's suite of tools is the cross-compiler for
        \code{arm-non-eabi}, which provides a toolchain to target the System V
        ABI (Application Binary Interface). This is a set of specifications that
        detail the calling conventions, object and executable file formats,
        dynamic linking semantics, and more, for systems complying with the
        System V Interface Definition, of which the Raspberry Pi is one. For
        example, it defines the Executable and Linkable Format, or ELF, which is
        a format for storing programs or fragments of programs on disk that are
        generated as a result of compiling and linking. Each ELF file is divided
        into sections, specifically:
        \begin{itemize}
            \label{tab:LinkerSections}
            \itemsep0em
            \item \code{.text} - executable code
            \item \code{.data} - global variables which are uninitialised at
                compile-time
            \item \code{.rodata} - read-only data i.e. global constants
            \item \code{.bss} - uninitialised global variables
        \end{itemize}

        These are covered in more depth in the discussion of the linking process
        in section \ref{sec:Linker}. Additionally the SysV ABI defines the
        \code{.comment}, \code{.note}, \code{.stab}, and \code{.stabstr}
        sections for compiler and linker toolchain comments and debugging
        information.

    \subsubsection{ARM environment}
       The ARM1176JZF-S processor implements the ARM11 ARMv6 architecture
       \cite{TRM}, supporting both the ARM and Thumb instruction sets\footnote{A
       subset of the most commonly-used 32-bit ARM instructions.  Each Thumb
       instruction is 16 bits long, and has a corresponding 32-bit ARM
       instruction with an equivalent effect on the processor model. While not
       useful and out-of-scope for this project, the instruction sets can be
       easily switched between to enable the programmer to optimize both code
       density and performance as they see fit.}. The processor contains 33
       general-purpose 32-bit registers and 7 dedicated 32-bit registers, 16 of
       which are accessible for general use at any one time in the ARM state.
       These are as follows:
       \begin{itemize}
           \itemsep0em
           \item \code{r15} - Program Counter
           \item \code{r14} - Link Register
           \item \code{r13} - Stack Pointer
           \item \code{r12} - Intra-Procedure-Call Scratch Register
           \item \code{r4-r11} - local variables to a function
           \item \code{r0-r3} - arguments passed to a function, and the returned
               result
       \end{itemize}

       The Current Program Status Register (CPSR) contains code flags, status
       bits, and current mode bits.  Another register, the Saved Program Status
       Register (SPSR), is similar to the CPSR but is only available in
       privileged modes. This contains the condition code flags, status bits,
       and current mode bits saved as a result of the exception which prompted
       the processor to enter the current mode.

       The architecture asserts a full descending stack: full, meaning
       the stack pointer points to the topmost entry in the
       stack\footnote{Contrasted to empty, which points to the next free
       location, i.e. the address at which the next item will be stored};
       and descending, meaning the stack grows downwards, starting from a high
       memory address and progressing to lower addresses as items are pushed.

       As a final note on correctly interacting with the ARM environment, any
       procedure calls must preserve the contents of registers 4 to 11 and the
       stack pointer. Further, subroutines calling other subroutines must save
       the return address (found in the link register) to the stack before
       calling that subroutine.

    \subsubsection{Tools}
        The following is a summary of the tools used to develop the project:

        \begin{center}
            \begin{tabular}{|l|l|}
                \hline			
                \textbf{Languages} & C, ARM assembly \\ \hline
                \textbf{Cross-compiler toolchain} & GNU Embedded Toolchain
                (\code{arm-none-eabi-*}) \\ \hline
                \textbf{Build automation} & GNU Make \\ \hline
                \textbf{Version control} & Git, hosted remotely on Github \\ \hline
                \textbf{Emulation} & QEMU \\ \hline
            \end{tabular}
        \end{center}

        The project uses the C language both due to its familiarity as well as
        its ease-of-setup on the embedded environment, however there are times
        in such an environment, and especially for operating systems
        development, that assembly is more suitable \cite{InappropriateC}, and
        was thus opted for instead. As already discussed, the GNU Embedded
        Toolchain has been used to target the ARM architecture for which the
        project is built.

        The GNU Embedded Toolchain consists of several utilities, all of which
        are used at various stages in the project's development:
        \code{arm-none-eabi-gcc} is responsible for compiling the C and ARM
        assembly files into object files; \code{arm-none-eabi-ld} is
        embedded-platform-independent linker, used to link multiple object files
        into a single \code{.elf} file; \code{arm-none-eabi-objcopy} converts
        the resultant \code{.elf} file into a binary (system executable, or
        \code{.img}) file; \code{arm-none-eabi-objdump} provides helpful
        debugging information about the final executable file (for example, used
        as a disassembler it presents the kernel image in assembly form); and
        \code{arm-none-eabi-gdb} provides the familiar interface of the GNU
        debugger.

        As the project increased in complexity, especially with the addition of
        multiple source files, GNU's Make utility was used to automate the build
        process. This involved becoming familiar with concepts regarding rules,
        with GNU's online manual page \cite{MakeManual} and \cite{MakeVariables}
        being of particular help.

        Throughout its early stages, the project operated solely in an emulated
        environment, simply as it provided quicker feedback with respect to
        testing, which is already limited and tedious in such an environment.
        For this prupose QEMU was consequently used. However, due to its lack of
        simulation of a system timer, an important aspect when programming
        interrupts and process scheduling, focus had to eventually be shifted
        towards operating on real hardware, limiting QEMU's influence on the
        project as a whole.
 
\subsection{System Overview}

\subsection{Project management}
