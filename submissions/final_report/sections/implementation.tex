\section{Implementation}
    The following section largely documents the system as it was developed
    chronologically, and is not representative of the order in which systems are
    initialised in the final piece of software. This better highlights the
    dependencies between each discrete stage in development and reinforces the
    plan-driven approach to the project as a whole.

\subsection{System initialisation}
    There are two main files which handle the entirety of system startup, namely
    \code{linker.ld} and \code{boot.S}, the former responsible for defining the
    layout of the final executable we will be producing, and the latter handling
    the setup of the C runtime environment and passing control to the main
    kernel function.

    \subsubsection{Linker Script}
        \label{sec:Linker}
        In order to create a kernel, or any program for that matter, we must
        link all compiled object files into a single executable. For user-space
        programs, that is, programs written to run in an established operating
        system, there are default scripts provided by the compiler which do
        this. Since the operating system on which we will run the kernel does
        not yet exist, we must create a linker script ourselves.

        We begin by declaring that the symbol \code{\_start} is the entry point
        for our entire program (this is usually \code{main} for user-space
        programs), meaning execution will jump to this address when the system
        starts. We first declare the symbols \code{\_\_start} and
        \code{\_\_text\_start} at address \code{0x8000}, which informs the
        bootloader where to place our kernel image. Addresses up to
        \code{0x8000} will be reserved for the stack. After this we must declare
        one by one each of the major sections which will be used in the ELF
        file, the first of which is the \code{.text} section, containing
        executable code.  The code from \code{boot.S} is placed in the
        \code{.text.boot} section, and we use the \code{KEEP} directive to
        inform the linker not to optimise the code in that section -- we want it
        running exactly what is written there. We declare the sections
        \code{.rodata}, \code{.data}, and \code{.bss} similarly, each time
        declaring global symbols for them should the need to use them as
        variables arise (as is the case, for example, when placing the metadata
        for pages directly after the kernel image, see Section \ref{sec:pages}).
        We also use the directive \code{ALIGN} to define a page size for the
        kernel image -- specifically, this sets the current address to the next
        available address that is divisible by the page size we set, 4096 bytes.

    \subsubsection{Initialising the C runtime}
        With our kernel image sections defined, we can actually write the code
        that will boot into our kernel, contained in the file \code{boot.S}. We
        begin by declaring that this is to be placed in the \code{.text.boot}
        section (as used by the bootloader) and we make our start symbol visible
        from any file using the \code{.global} directive -- this is required for
        the linker to see which location to jump to at system startup.

        The project was initially written for the Raspberry Pi 2, containing the
        quad-core Cortex-A7 CPU. However, since multicore programming entails
        extra difficulty even in a familiar user-space environment, it was
        always designed to only use one of these cores. The following code
        remains included in the project, wrapped in a test to determine which
        processor we have compiled for, and sends three of the four cores to
        hang. We will discuss it now to introduce the idea of the ARM
        coprocessor:

        \lstset{style=asm}
        \begin{lstlisting}[caption={Code to halt three of the four cores},captionpos=b]
_start:
    mrc p15, #0, r1, c0, c0, #5
    and r1, r1, #3
    cmp r1, #0
    bne halt
        \end{lstlisting}

        The \code{mrc} and \code{mcr} instructions allows for interaction with
        the system control processor, and denote ``move data from coprocessor to
        ARM register'' and ``move data from ARM register to coprocessor''
        respectively. The purpose of this is to control and provide status
        information for the functions implemented on the ARM1176JZF-S processor
        \cite[pg.~3-2]{TRM}, and exposes optional\footnote{ARM only provides
        specifications for processors; it is down to hardware manufacturers to
        implement their designs.} additional functionality that is not provided
        by the core instruction set. Among others, these functions include:
        \begin{itemize}
            \itemsep0em
            \item System control and configuration
            \item MMU control and configuration
            \item Cache control and configuration
            \item Direct Memory Access (DMA) control
            \item System performance monitoring
        \end{itemize}

        As it stands, the project only makes use of the first two. The code
        block itself reads the Multiprocessor Affinity Register \cite{MPIDR} for
        the identifier of the current CPU it is testing, and if neither of the
        two lower bits returned are 1, then the core is sent to halt
        indefinitely in a low-power state.

        With just a single core to develop for, the next step is to set up the
        stack pointer at address \code{0x8000}. The program counter for the
        kernel starts at address \code{0x8000} and grows upwards, and, since the
        stack grows downwards, it is safe to place it at this address without it
        interfering with the kernel. Next the start and end of the Basic Service
        Set (BSS) is loaded into registers -- recall that this is where
        statically allocated global variables are stored. Since the C standard
        requires uninitialised global variables to be zeroed, we must zero out
        (that is, store the value 0) in the registers between the addresses of
        \code{\_\_bss\_start} and \code{\_\_bss\_end}.

        The final responsibility of \code{boot.S} is to transfer control to our
        kernel entry point, \code{kernel\_main}, by loading the address of this
        symbol into the program counter. Overall, this small portion of the
        codebase initialises a minimum C environment, meaning the stack is
        initialised and the BSS segment zeroed before we pass control to our
        custom kernel. Note that the use of registers 0, 1, and 2 is avoided as
        the bootloader uses these to pass system parameters and hardware
        information to the main function\footnote{Namely, the device from which
        the system was booted, the ARM Linux Machine Type (\code{0xc42} for the
        Pi), and the address of the atags, which contain more important
        information such as available memory.} at runtime.

\subsection{Organising memory}
    \subsubsection{Atags}
        One important piece of data passed by the bootloader to the main kernel
        function is the address of the ``atags'' -- this is a list of tags which
        describe various system parameters such as total system memory, the
        initial ramdisk, and command-line parameters to pass, and is passed
        through address \code{0x100} on the Raspberry Pi 1. Throughout the
        execution of the operating system, computations will require memory and
        since the project functions entirely in kernel-space, any and all memory
        is available to use. To impose some structure on the memory and manage
        it effectively, however, we organise it into 4kiB pages, allowing for
        equal-sized blocks of memory, which are neither insignificantly nor
        prohibitively large, to be allocated and tracked. Therefore, the most
        important piece of information among the atags is the total system
        memory, which the project uses in its implementation of a dynamic memory
        allocator.

        In order to parse this list of tags, we need the kernel to understand
        the layout of the data it is being passed. In particular, each tag
        consists of two values: an unsigned 32-bit integer denoting the length
        of the tag (in 32-bit words), and the tag itself, details of which are
        found at \cite{atags}. This provides information concerning the memory
        tag itself, namely that it contains two unsigned 32-bit integers
        describing memory size and start address, in this order. Therefore, we
        define the C structure \code{atag\_mem} to easily access these two
        fields once we come across the memory tag. Thus, to determine the total
        memory available we iterate over the atags list until we find the memory
        tag, cast this to our \code{atag\_mem} structure, and consequently
        return the field denoting the size of system memory.

    \subsubsection{Pages}
        \label{sec:pages}
        The total number of pages is the total size of memory divided by the
        page size, which we have set to 4kiB. In order to effectively manage
        each page, we create a list containing metadata for each page: this
        metadata includes, for example, the virtual address to which it maps,
        along with bit-field flags detailing whether the page is allocated, if
        it available for sharing, if it is a kernel page (for when user-space is
        implemented), and whether it is a regular page or a page on the heap.
        We use the global symbol \code{\_\_end}, declared in the linker script,
        to place the page metadata list directly after the end of the kernel
        image.

        To allocate a page, we need of knowledge of which ones are free to do
        so, for which we create a linked list of all such pages. Then all that
        is needed is to return a pointer to its location in memory and zero it
        (for security), modify the appropriate flags in the page array, and
        remove it from our free pages list. When a page's use is no longer
        required, it makes sense to make it available for future allocations,
        for example when a process has finished executing (see Section
        \ref{sec:cleanup}). Thus, to free a page we use its physical address to
        index into the array containing all pages, set the \code{allocated} to
        0, and add it back to the list of free pages.

    \subsubsection{Dynamic memory allocator}
        To allocate memory dynamically, and less restrictively than entire pages
        at a time, we reserve a 1MiB portion of memory directly after the page
        metadata for heap memory, which is used to allocate segments of memory
        instead, with a similar interface to the C standard library's
        \code{malloc} and \code{free}. This choice of 1MiB is fairly arbitrary,
        but is not too restrictive for most uses of dynamic memory and does not
        use too large a portion of memory that will eventually be used by
        user-space.
        
        Memory allocation is implemented by first defining for each allocation a
        header containing the allocation size, in bytes, and whether it has been
        allocated, and then using these headers to form a linked list. Thus, in
        order to grant an allocation we must find a header that is at least the
        requested number of bytes in size, and not currently in use. If the
        best-fitting segment, that is, the segment with the smallest size that
        satisfies the request, is relatively large compared to what was
        requested, we split it so that we may use what is effectively ``left
        over'' to satisfy some future request.

        When freeing memory allocations, we mark the segment as unallocated by
        modifying the bit in the allocation header and merge adjacent free
        segments in the linked list into one, thus decreasing the likelihood of
        internal fragmentation -- unused or unusable memory within the segment
        \cite[pg.~363]{DinosaurOS}. Coalescing adjacent free segments to the
        left is shown below; the process is identical for coalescing to the
        right, except that it modifies the pointer to the \code{next} segment
        header instead.
        \lstset{language=c}
        \begin{lstlisting}[caption={Coalescing heap segments to the left},captionpos=b]
/* merge segments to the left */
while (seg->prev != NULL && !seg->prev->allocated) {
    seg->prev->next = seg->next;
    seg->prev->segment_size += seg->segment_size;
    seg = seg->prev;
}
        \end{lstlisting}

        When initialising the heap at system startup, we must first allocate the
        appropriate number of pages and mark them as kernel heap pages, then
        initialise the linked list of segments by declaring a single segment
        1MiB in size. Although the total heap size remains the same, it will
        become split into increasingly many segments, all forming a linked list,
        as allocation requests are satisfied.

\subsection{Serial Output}
    \label{sec:GPIO}
    An operating system would be useless without an efficient means of
    interacting with it during execution, so the next task to present itself was
    that of interfacing with the Universal Asynchronous Receiver/Transmitter, a
    peripheral on the Pi, which is capable of serial\footnote{One bit at a time}
    communication. While output would evolve to be via HDMI, it was simpler to
    initialise this when working within QEMU, and also prompted for an intuitive
    interface for GPIO to be written, which would again become useful when
    debugging with HDMI output.

    \subsubsection{Peripherals}
        As mentioned, a peripheral is a device with a specific address from and
        to which it may read and write data, and all interactions with
        peripherals make use of Memory Mapped I/O (MMIO) to do so on the
        Raspberry Pi -- the process of performing I/O by reading from and
        writing to predefined memory address. Moreover, each peripheral may be
        described by an offset from the Raspberry Pi's Peripheral Base Address.
        This varies for different models of the Pi, but on the Raspberry Pi 1
        Model B+, this is located at address \code{0x20000000}, and the physical
        address for peripherals span from this base address up to
        \code{0x20ffffff}. The peripheral itself contains a collection of
        registers which may be read and written, and these are defined at
        offsets from that specific peripheral's base address (see Table
        \ref{tab:UART} for clarification).

        \begin{table}
            \centering
            \begin{tabular}{|c|l|c|}
                \hline
                \textbf{Offset} & \textbf{Register} & \textbf{Size} \\
                \hline
                \code{0x00} & Data Register & 32 \\ \hline
                \code{0x04} & RSRECR & 32 \\ \hline
                \code{0x18} & Flag Register & 32 \\ \hline
                \code{0x20} & Unused & 32 \\ \hline
                \code{0x24} & Integer Baud Rate Divisor & 32 \\ \hline
                \code{0x28} & Fractional Baud Rate Divisor & 32 \\ \hline
                \code{0x2c} & Line Control Register & 32 \\ \hline
                \code{0x30} & Control Register & 32 \\ \hline
                \code{0x34} & Interrupt FIFO Level Select Register & 32 \\ \hline
                \code{0x38} & Interrupt Mask Set Clear Register & 32 \\ \hline
                \code{0x3c} & Raw Interrupt Status Register & 32 \\ \hline
                \code{0x40} & Masked Interrupt Status Register & 32 \\ \hline
                \code{0x44} & Interrupt Clear Register & 32 \\ \hline
                \code{0x48} & DMA Control Register & 32 \\ \hline
                \code{0x80} & Test Control Register & 32 \\ \hline
                \code{0x84} & Integration Test Input Register & 32 \\ \hline
                \code{0x88} & Integration Test Output Register & 32 \\ \hline
                \code{0x8c} & Test Data Register & 32 \\ \hline
            \end{tabular}

            \caption{Each register is described by an offset from the UART base
            address, \code{0x20201000}.}
            \label{tab:UART}
        \end{table}

        There are several steps to initialise the UART for use on the Pi, and
        involves setting various configuration flags. The following steps are
        performed in order in \code{uart\_init()} in \code{gpio.c}:
        \begin{enumerate}
            \itemsep0em
            \item disable all aspects of the UART
            \item disable all GPIO pins
            \item disable pins 14 and 15
            \item clear all pending interrupts
            \item set up the baud rate of the connection
            \item enable FIFOs and set word length to 8 bits
            \item disable all interrupts
            \item enable the UART hardware, and the ability to transmit and
                receive data
        \end{enumerate}

        To send a byte to the data register, we wait until the FIFO (the data
        structure by which the UART sends and stores information) is not full
        and write the byte to the data register. Receiving a byte is done by
        waiting until the FIFO is non-empty and returns whatever is in the data
        register. Thus we have serial input and output, and may use this to
        implement \code{putc} and \code{getc} respectively. When running this
        build on QEMU, passing the \code{-serial} flag enables the sending and
        receiving of serial output via the host computer, thus we can specify
        \code{stdin} to be able to send character input via the host system's
        keyboard. This enables us complete interactivity with the kernel in the
        emulated environment.

\subsection{Interacting with the GPU}
    While QEMU was a powerful tool to allow for quick development and
    testing of core low-level features, as discussed its lack of simulation
    of a system timer required that the project eventually be moved to real
    hardware to tackle core features such as processes and interrupts.
    Furthermore, the Pi comes without a dedicated serial port, therefore without
    a TTL-to-USB adapter we are unable to use the UART to output to a real
    screen. Instead, it is much more natural to use the onboard HDMI port to
    output to a display, and for this we require communicating with the GPU.

    Displaying anything to the screen via the HDMI requires the use of a
    framebuffer; this is a piece of memory which is shared between the CPU and
    GPU. The CPU writes RGB pixels to the buffer and the GPU reads from it to
    render the pixels to whichever output device is connected. We must first
    request a framebuffer from the GPU, and this interaction takes place over
    the mailbox peripheral.

    \subsubsection{Mailbox Peripheral}
        The mailbox peripheral is a peripheral, just like the UART, which
        facilitates communication between the CPU and GPU, more specifically the
        VideoCore Operating System, and starts at offset \code{0xb880}
        \cite{Mailboxes}. It contains a read register, located at offset
        \code{0x0} from the base, which holds messages sent by the GPU; a status
        register, located at offset \code{0x18}, which is used to signify
        whether the read register is empty or full; and a write register,
        located at offset \code{0x20}, which the CPU can use to send data to the
        GPU. Since the mailbox peripheral can also be used to send and receive
        information about multiple systems, such as power management, audio, and
        the on-board camera, the peripheral requires communication through
        certain channels. This is simply a number that specifies the meaning
        behind the data being sent; for the framebuffer, we communicate via
        channel 1.

        Crucially, the process of communicating with the GPU via the mailbox
        peripheral differs depending on the model of Raspberry Pi being used;
        since the project was initially intended to run on the Pi 2 Model B, an
        interface was written for this version, however since it is a much
        simpler process on the Pi 1 Model B+, after some weeks debugging and
        making little progress, the decision to switch the target platform was
        switched at this point. Within the source code are both methods,
        and both are guarded by macros (see Section \ref{sec:directives} on
        Makefile directives) which will prevent compilation of the wrong one.

\subsection{Interrupts and Exceptions}
\subsection{System Timer}
\subsection{Processes}
    \subsubsection{Handlers}
    \subsubsection{Reapers}
        \label{sec:cleanup}
    \subsubsection{Initialising Processes}
\subsection{Scheduling}
\subsection{Interacting with the Memory Management Unit}
\subsection{Synchronisation}
\subsection{Inter-process Communication}
\subsection{User interaction}
