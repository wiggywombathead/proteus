\section{Background}
\subsection{Relevant Material}
    To this end, there are a handful of modern resources for getting involved
    with operating systems development -- a particularly useful one at the time
    of first carrying out research for the project's proposal was
    \code{wiki.osdev.org}, which contains information about the creation of
    operating systems and acts as a community for hobbyist operating system
    developers. However, much of the focus is on the x86 platform and past
    providing a brief overview of the idiosyncrasies of the Raspberry Pi as well
    as the code to get a barebones kernel to boot, there is little material on
    the specifics required to get core systems working on the platform.
    Cambridge's \textit{Baking Pi} \cite{BakingPi} provides more help in this
    regard, with Alex Chadwick's comprehensive tutorials proving an invaluable
    resource for information such as accessing registers and peripherals
    specific to the Raspberry Pi. The project can, however, be much further
    extended to guide through the implementation of core operating system
    concepts such as memory management, the process model, interprocess
    communication, and filesystems. Another aspect in which this series of
    tutorials diverges with the goal of this project is the language in which it
    has been implemented -- while assembly is an undeniably language in which to
    be competent, it is not the most easily-understandable, in stark contrast to
    what this project hopes to achieve. The resource which aligns most tightly
    with the aim of this project is \cite{jsandler}, whose tutorials have served
    as an outline to how many key features of the project have been implemented.
    
    Finally, other notable resources which are in place to teach general
    operating systems development are Stanford's \textit{Pintos} \cite{Pintos}
    and Tanenbaum's MINIX operating system \cite{MINIX}; the former was written
    to accompany the university's CS140 Operating Systems course, while the
    latter is an illustrative operating system written alongside the book
    \textit{Operating Systems: Design and Implementation}, as a means of
    providing concrete examples of how operating system features are implemented
    in practice. Helin and Renberg's \textit{The Little Book About OS
    Development} \cite{littleosbook} also serves as a guide to writing one's own
    operating system. The only drawback to these three is their focus on the x86
    architecture, and while they are useful resources it is in concept only,
    given the gap which was found to quickly form from focusing on a different
    processor.

\subsection{Why is this project worthwhile?}
    The project is worthwhile firstly as it provides an accessible gateway into
    systems programming and operating systems development. Given the relative
    difficulty and additional effort required to get involved with this area of
    software development as opposed to others, for example by reading technical
    reference manuals and building an intimate knowledge of the hardware with
    which you are working, it therefore finds its use in easing this transition
    and making the learning curve associated with its involvement less
    intimidating and more approachable. In doing this, the project is also
    worthwhile in that it demystifies some of the key considerations that go
    into operating system implementations, not only in high-level concepts such
    as processes, but also the low-level with notions such as memory-mapped I/O
    and the processor's registers. In providing this opportunity to see theory
    in practice, it further opens up the opportunity for experimentation and
    invites practical self-learning, and hopefully clarifying why existing
    operating systems work the way they do.

    While there are similarities to be drawn between the aims of this project
    and those of the current background material, both looking to create a more
    accessible way in to operating systems development, this project addresses
    the gap that they leave unfilled by tackling a different architecture, as
    well as in approaching feature implementation in a more modular manner. Thus
    the project forms one more part in the ecosystem of introductory and
    instructional operating systems.

\subsection{Useful concepts}
    \textbf{Operating System} \\
    \textbf{Kernel} \\
    \textbf{Freestanding environment} \\
    \textbf{Cross-compiler} \\
    \textbf{Linker} \\
    \textbf{Exception} \\
    \textbf{Process} \\
    \textbf{Context Switch} \\
    \textbf{Synchronisation} \\
    \textbf{Inter-process Communication} \\
    \textbf{Peripheral} \\
    \textbf{Memory Mapped I/O} \\
    \textbf{Paging} \\
    \textbf{Virtual Memory} \\

    \noindent\textbf{Note:} Throughout this report the units kiB and MiB are used (in the
    context of memory only) to denote $2^{10} = 1024$ bytes and
    $(2^{10})^2=1,048,576$ bytes, respectively.  This is to ensure clarity and
    avoid confusion with their SI-prefixed counterparts, namely kB and MB, which
    instead correspond to $10^3$ and $10^6$ bytes.
