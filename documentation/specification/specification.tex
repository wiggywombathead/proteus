\documentclass[10pt,a4paper]{article}

\bibliographystyle{ieeetr}

\usepackage[margin=1in]{geometry}
\usepackage{graphicx}
\usepackage{subfig}
\usepackage{amsmath}
\usepackage{url}
%\usepackage{diagbox}

\newcommand{\code}[1]{\texttt{#1}}

\title{A moduler kernel for the Raspberry Pi: Project Specification}

\begin{document}

\maketitle

\begin{center}
    Thomas Archbold \\
    1602581 \\
    University of Warwick \\
\end{center}

\section*{Background}
In most operating systems, many design decisions are made in order to keep
things simple for the user, by keeping most of the technical details hidden. In
most cases, this is an appropriate approach: needlessly offering more choices
for low-level tasks that are usually handled by the operating system, such as
CPU and disk scheduling algorithms, would only serve to confuse the average
user. It may actually be detrimental to the security and the stability of the
system by opening up more opportunities for errors to be introduced.  This more
insulated approach does mean, however, that the user never really knows what is
going on ``under the hood'', and indeed whether greater performance can be
achieved by making \textit{different} fundamental decisions.  Furthermore, a
number of operating systems exist for the Raspberry Pi, some focusing on
ease-of-installation, others on Internet of Things integration, but none exist
to serve as a testbed for these low-level decisions. This project aims to fill
this gap for the operating systems enthusiast, one who wishes to test for
themselves the different approaches to CPU scheduling, disk scheduling,
interprocess communication, and filesystems. It will give the user the ability
to dynamically change the fundamental ways in which their machine operates by
loading different modules to handle different tasks, without the need to
reboot, enabling for a more flexible operating system where such things can be
tweaked at any point.

\section*{Main goal}
The goal of this project is to create a modular operating system for the
Raspberry Pi 2 Model B that is capable of dynamically loading modules to tackle
CPU scheduling, disk scheduling, interprocess communication, and filesystems in
a variety of ways. Specifically, it must have some way to run and switch
between multiple processes using a CPU scheduler; interact with a hard disk
drive and a disk scheduler for permanent/mass storage; and be able to create,
read, update, and delete files and directories using a custom filesystem.  To
achieve this, it must implement an interface for loading/removing modules,
similar to Linux's \code{insmod} and \code{rmmod} \cite{insmod}, and must do so
safely and stably.  Furthermore, as executing processes forms a key functional
requirement for the project, there must be a convenient way to load programs
into memory and begin their execution. A solution to both of these problems is
to implement a basic shell/command interpreter.

Finally, a key objective of this project will be to get the operating system to
work entirely on real hardware, and not solely in an emulated environment. This
means it must be able to boot from the Pi's SD card using some bootloader, as
well as taking input from a keyboard connected via USB, and printing output to
a physical screen via the HDMI port on the Pi.

\subsubsection*{Loadable modules}
The project must implement the following as loadable modules, which may be
switched to on-the-fly by the user:
\begin{itemize}
    \item CPU Scheduling:
        \begin{itemize}
            \item First Come First Served
            \item Round Robin
            \item Shortest Job First
            \item Shortest Remaining Time First
            \item Priority Scheduling (preemptive and non-preemptive)
            \item Lottery Scheduling
        \end{itemize}
    \item Disk Scheduling:
        \begin{itemize}
            \item First Come First Served
            \item Shortest Seek Time First
            \item SCAN and C-SCAN (elevator algorithm)
            \item LOOK and C-LOOK
        \end{itemize}
    \item Interprocess Communication
        \begin{itemize}
            \item Message passing
            \item Shared memory
        \end{itemize}
    \item Filesystem
        \begin{itemize}
            \item persistent
            \item load-on-request
        \end{itemize}
\end{itemize}

\subsection*{Stretch goals}
Some stretch goals which would not be entirely necessary for the success of the
project, but should be implemented to show understanding of more complex
structures, would be primarily some more intricate scheduling algorithms,
including the following \cite{CFS,BFS,DinosaurCPU,O(n)Scheduler,O(1)Scheduler}:
\begin{itemize}
    \item Completely Fair Scheduler
    \item Multiple Queue Skiplist Scheduler, MuQSS
    \item Multilevel Queue and Multilevel Feedback Queue
    \item $\mathcal{O}(n)$ Scheduler
    \item $\mathcal{O}(1)$ Scheduler
\end{itemize}

In order to give the operating system more purpose and to increase usability,
the collection of relatively simple programs on offer should be extended,
including a mix of long running CPU- and I/O-bound programs. This will mean
that the relative performance of the schedulers may be seen more easily. While
the Not Recently Used (NRU) algorithm will be used for page replacement due to
its low overhead and relatively decent performance, other algorithms could be
explored and implemented as modules. These may include: First-In-First-Out (for
its poor performance), the Clock Page Replacement algorithm, and the Least
Recently Used algorithm \cite{PageReplacement}.

\subsection*{Further extensions}
Beyond these goals, further extensions would focus on increasing the usability
of the system, and start to shape it into one which someone might actually use
to get things done. One of the simpler ways to achieve this would be to write a
text editor. It is, however, highly unlikely that this will be achieved given
the time-frame of the project, but would make for a nice goal much further into
the lifetime of the operating system.

\subsection*{Out-of-scope}
There are several features that will not be implemented in the project. These
include any form of graphical interfaces, networking, and security, simply due
to the complexity they would add and the extra investment required to complete
them.

\section*{Methodology}
The methodology best suited to the project will be a mix between a plan-driven
and agile approach; the basic requirements of the system will not change over
the course of the project, and furthermore there will be a rigid structure with
regards to dependencies that the project is likely to abide by (for example, the
system will have to boot before implementing memory management before
implementing scheduling algorithms). Therefore, the early stages of the project
will benefit from a plan driven approach, most likely an Incremental one to
allow for some choice in what to implement, as opposed to the more restrictive
structure of a Waterfall methodology. After the foundations have been
implemented successfully, the project is likely to open up and take a more agile
approach; Scrum cycles are likely to be useful dedicating a large portion of
concentration implementing one feature, or fixing specific bugs, at one time, in
an incremental manner.

Throughout the project, weekly meetings will be held with the supervisor in
order to discuss any current problems and talk through approaches to solutions
(especially for the more complex ones), the overall progress of the project, as
well as the direction in which it is headed. It would also be at this time that
progress is compared with the timetable, and any notes and adjustments are made
dynamically in order to fully stay on top of the work.

\section*{Testing}
The project will be tested in an incremental manner. Especially to begin with,
it is vital that some systems operate correctly before moving on and developing
other areas. As the project progresses and its complexity increases, unit tests
will be written to systematically cover all, or at least most, likely paths of
execution, and to account for each of these. The most fundamental requirement to
fulfill while testing the solution will be stability, that is to say, whether
the system is able to safely switch between different modules and continue
operation. Of course, the solution must also be correct: the user must be able
to switch dynamically between the different modules, and the system must react
accordingly. There must be a way to verify that the system is indeed operating
in the way that is expected from the user, and again, unit tests and
verification software must be produced to ensure this.

\section*{Timetable}

\section*{Technologies}
The following technologies will be used by the project:
\begin{itemize}
    \item Git - version control
    \item Github - to access the project from multiple sources, as well as to
        back it up
    \item C - the language in which most of the operating system will be
        implemented
    \item ARM assembly - used when C is unavailable/inappropriate
        \cite{CannotDoC}
    \item GCC cross compiler for ARM EABI - for cross compiling for the target
        processor, the Cortex-A7 \cite{CrossCompilation}
    \item QEMU - for emulating the Pi to allow quicker and safer testing
        \cite{qemu}
    \item Make - used to speed up the build process
\end{itemize}

\section*{Resources}
The following documentation will be used throughout for reference to the
architecture of the Cortex-A7 processor and its intruction set:
        \begin{itemize}
            \item Cortex-A7 MPCore Technical Reference Manual
            \item ARM Cortex-A Series Programmer's Guide
            \item Broadcom BCM2835 ARM Peripherals Manual
        \end{itemize}

\section*{Legal, social, ethical, and professional  considerations}
All software used to build the project is available to use under the GNU Public
License. Throughout the project's development, some testing will be required
from people other than the creator, to gain feedback especially with regards to
usability; these people are likely to be friends and colleagues, hence the
social, ethical, and professional issues are insignificant.

\bibliography{bibliography}

\end{document}
