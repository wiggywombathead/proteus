\documentclass[10pt,a4paper]{article}

\bibliographystyle{ieeetr}

\usepackage[margin=1in]{geometry}
\usepackage{graphicx}
\usepackage{subfig}
\usepackage{amsmath}
\usepackage{url}
\usepackage{pgfgantt}
\usepackage{lscape}
\usepackage{pdfpages}
% \usepackage{diagbox}

\graphicspath{{./figs/}}

\newcommand{\code}[1]{\texttt{#1}}

\title{A modular kernel for the Raspberry Pi: Progress Report}

\begin{document}

\maketitle

\begin{center}
    Thomas Archbold \\
    1602581 \\
    University of Warwick \\
\end{center}

\section{Introduction}
% problem that project addresses, motivations (importance of undertaking)
% make sure objectives are clear and clarify why it is a significant undertaking
% and of suitable level for third year project in computer science

\section{Background}
% all research I have put into it until this point - good understanding of
% background and how it fits into landscape (does not exist in isolation, before
% or after conception)
% indication of how background information was gained - a few citations that
% have been key sources for project

\section{Current progress}
The project is currently at a point at which the operating system is able to
successfully boot in the emulated environment provided by QEMU. Since it has
been capable of doing this since \code{boot.s} was written, early on in Term 1,
it is important to note the specific stages of initialisation performed by the
kernel at this point, as well as discuss the environment setup that has enabled
this point in development to be reached.

\subsection{Development environmet}
The project is being developed on a machine running Linux kernel version 4.16
onwards. Since the target environment, the Raspberry Pi 2 Model B, is different
to that on which it is being developed, a cross-compiler is required to compile
code that will run on the target machine, as opposed to the host. In particular,
available for download on the ARM developer website \cite{GNUtoolchain} is the
GNU Embedded Toolchain, which provides tools to target ARM Cortex family of
processors, including the GNU Compiler Collection (GCC). Conveniently this suite
of tools is available from Arch Linux's package manager, pacman \cite{pacman},
and this is the version of the cross-compiler used in the makefile.

Before writing any code, as the author had little-to-no prior experience in
systems programming, research had to be undertaken in order to get acquainted
with this environment. In particular, this involved skimming over the various
peripherals manuals, technical reference manuals, and programmer's guides for
programming on the Raspberry Pi to learn more about its hardware and how to
interface with it using ARM assembly. \cite{BCM2835} and \cite{BCM2836} detail the
peripherals on board the Raspberry Pi 2 Model B, the layout of their related
registers, and how to read and write them to do meaningful things with the
hardware, while \cite{TRM} and \cite{PG} provided help on ARM assembly's syntax,
and how and when to use specific instructions.

Particularly important so far have been the sections of the peripherals manual
on GPIO and UART, as until the implementation for the mailbox interface is
working, all input and output is done through the serial connection provided by
the UART.  Since there were issues with getting the Pi to run on real hardware,
information about the GPIO peripheral was needed in order to write basic
low-level debugging functions, mainly in the form of getting the green ACT LED
to blink for various return values of functions.

\subsection{boot.s}
The first piece of code to be written was \code{boot.s}, which is responsible
for providing the basic setup of the entire system, which includes initialising
a minimum C environment. In particular, it sends three of the four cores on the
CPU to shutdown (to decrease overall complexity of the system, as discussed in
the specification), initialises the stack pointer at address \code{0x8000}, sets
up the BSS segment (where statically-allocated variables that are not explicitly
initialised are stored) and zeroes it out (as required by the C standard), and
then loads our C kernel entry point, \code{kernel\_main}, into memory to begin
its execution. Note that the Program Counter for the kernel starts at address
\code{0x8000} and grows upwards, so the stack can safely start at \code{0x8000}
without interfering with the kernel (as it grows downwards).

\subsection{linker.ld}
The code in \code{linker.ld} is responsible for linking all of the compiled
object files into one final executable. There are scripts which do this for
user-space programs, but since we are our own user-space, being the kernel, we
have to create one for ourselves. The various sections that the script defines
are as follows:
\begin{itemize}
    \itemsep0em
    \item \code{.text} - contains executable code
    \item \code{.rodata} - read-only data i.e. global constants
    \item \code{.data} - global variables initialised at compile-time
    \item \code{.bss} - uninitialised global variables
\end{itemize}

We also define the entry point of our entire operating system in this script,
namely the \code{\_start} routine from \code{boot.s}. This script also sets the
symbols \code{\_\_start} and \code{\_\_text\_start} to be \code{0x8000}, which
is where the bootloader will put the kernel image - the code from \code{boot.s}
will be put in the first part of this section, \code{.text.boot}. We use
\code{KEEP} to tell the compiler not to try to optimise the code in
\code{.text.boot}, and \code{ALIGN} sets the current address to the next
available page (the next address divisible by 4096). The \code{,rodata},
\code{.data}, and \code{.bss} sections are then declared in much the same way.

\subsection{Makefile}
The makefile was written to speed up the build process, and there are only a few
features to note. First is that here we specify that we are using the
\code{arm-none-eabi} toolchain, for the compiler to target the Raspberry Pi's
architecture as opposed to our own, in particular the Cortex-A7 processor. The
\code{-fpic} compilation flag is currently being used while we are ignoring the
Memory Management Unit, and in particular virtual memory, on the Pi, as it
creates position-independent code, and will keep separate applications from
interfering with each other within this single address space when processes are
implemented. The \code{-ffreestanding} compiler and linker flag, and the
\code{-nostdlib} linker flag, specifies that we are writing code in a
freestanding environment, and as such do not expect much of the C standard
library to exist, or for program startup to necessarily to be at \code{main()}.
Specifically, we only have access to the following header files:
\code{<float.h>}, \code{<iso646.h>}, \code{<limits.h>}, \code{<stdalign.h>},
\code{<stdarg.h>}, \code{<stdbool.h>}, \code{<stddef.h>}, \code{<stdint.h>}, and
\code{<stdnoreturn.h>}. The rest of the standard library must be implemented
ourselves.

\subsection{Atags}
The first piece of meaningful setup that can be done when the kernel is booted
is to get information about the memory available to the system. On the Raspberry
Pi, the bootloader creates creates a list of information about the hardware
called Atags, places it at address \code{0x100}, and passes it as the third
parameter to \code{kernel\_main} in register 2. Each tag in the list contains a
header consisting of two unsigned 32-bit values: the size of the tag (in 32-bit
words), and the tag value. Each header is then followed by information specific
to that tag, aside from \code{ATAG\_NONE}, which has no associated data, and
\code{ATAG\_CORE}, whose data is optional. To access the information in each of
the tags when we come across them, we must match the layout of each of the tags
\cite{atags} by defining appropriate C structs in \code{atag.h}.

To find the amount of memory on the device, we can skip through the Atags list
(using pointer arithmetic and information about the tag's size in its header)
until we come across the \code{ATAG\_MEM} tag. Then it is simply a case of
return the value in the \code{size} field of the \code{atag\_mem} struct.

\subsection{Organising memory}
Throughout the operating system's execution, different processes will require
memory to perform computations. Although the only thing doing anything
meaningful at the moment is the kernel, which can theoretically use any memory
it wants, in order to impose some order for later implementations of processes
and user space, we split the available memory up into 4KiB pages. The total
number of pages is therefore given by the total amount of memory divided by the
page size.

To organise the pages, we give each page a header which stores metadata about
the page, including whether the page has been allocated, whether it is a kernel
page, and whether this page is part of the heap (used later when dynamically
allocating memory). We organise all of the page headers into a linked list
directly after the end of the kernel image, using the \code{\_\_end} variable
from the linker script. Each page also stores the virtual address to which it
maps; as virtual memory has not yet been implemented, a page's virtual address is
simply its index in the page list multiplied by the page size. All that remains
is to iterate over the page header list to initialise each page's metadata, and
add each page to a linked list of all the free pages.

Naturally the next feature implemented was allocating and freeing pages.
Allocating a page is done by simply popping the head of the free page list,
setting the appropriate flags, and returning the address of the page. Freeing,
meanwhile, is done by passing the address of the page to free, again setting the
appropriate flags, and appending this page back to the fre page list.

\subsection{Allocating memory}
A 1MiB portion of memory located directly after the page headers is reserved for
the heap - while the choice of 1MiB is fairly arbitrary, it should be large
enough to suffice for all dynamic memory needs, and small enough to not use a
significant portion of memory that may be desired by user code. We define the
struct \code{heap\_segment} for keeping track of heap allocations, such as the
segment size and whether it has been allocated (useful for avoiding external
fragmentation later), and initialise the heap by declaring a single heap segment
whose size is equal to that of the heap - as more memory is allocated, this
initial segment will be split into smaller ones, which in turn may be split
further to satisfy requests for differing amounts of memory. Whenever memory is
requested, we add the size of the header to the request and 16-byte align it, so
as to actually reserve some space for the heap segment metadata.

To allocate a segment, we step through the list of segments in the heap and look
for the one best satisfying the number of bytes requested, and not in use. If
the current segment is large (i.e. the segemnt size if $\ge2$ times the header
size), we split it into two segments and only use one of them. Once a segment
satisfying the request is found, we return a pointer to the memory directly
after the header. To free an allocation, we set the appropriate flags, and then
attempt to merge consecutive free segments, checking both to the left and the
right of the current segment.

\subsection{Serial output}
Initial output was done using the UART on board the Pi, meaning text was sent
and received through serial ports. This was mainly due to simplicity in early
builds of the system, and while this can be achieved in the final version of the
project by using a USB-to-TTL cable, ideally it will use the HDMI port on the Pi
instead, which requires interfacing with the Mailbox peripheral (discussed
later). This was all done by interacting with the GPIO pins on the Pi, which is
done entirely through Memory Mapped I/O (MMIO) - that is, by reading from and
writing to predefined memory addresses. A peripheral on the Raspberry Pi is
simply an address to and from which you may read and write data, and all may be
described by an offset from the Peripheral Base Address; this is
\code{0x3f200000} on the Raspberry Pi 2 Model B. Moreover, a register is a
32-bit chunk of memory that a peripheral may read from or write to. The BCM2835
Peripherals Manual gives the UART base address as \code{0x7e201000}. Thus, in
\code{gpio.c}, after setting all the required flags for using the UART, we can
implement a serial \code{putc()} by checking that the FIFO is not full and
writing our data to the Data Register, and \code{getc()} by checking that the
FIFO is non-empty and reading from it. \footnote{From the manual: ``Physical
addresses range from \code{0x20000000} to \code{0x20ffffff} for peripherals. The
bus addresses for peripherals are set up to map onto the peripheral bus address
range starting at \code{0x7e000000}. Thus a peripheral listed at
\code{0x7ennnnnn} will be available at physical address \code{0x20nnnnnn}."}

\subsection{HDMI output}
The final goal, however, is to not use any extra adapters to make serial output
work - instead, output will be through the HDMI port on the Pi and to do so,
familiarisation with the Mailbox peripheral has been important. The Mailbox is a
peripheral that facilitates communication between the ARM CPU and the VideoCore
GPU \cite{Mailboxes}, and starts at offset \code{0xb880}. We may get data from the GPU via the
read register, pass data to the GPU using the write register, and check if
either of these are empty or full using the status register, at offsets
\code{0x00}, \code{0x20}, and \code{0x18} respectively. Furthermore, a channel
is a number that gives meaning to the data being sent to and received from the
GPU - for interacting with HDMI, we need the Property channel, channel 8. This
provides a means to get and set data about various hardware devices, one of
which is the framebuffer.

In order to ask the GPU for a framebuffer, we need first to be able to
communicate with it by sending messages and parsing the received response. The
messages we send it, for example, are to set the framebuffer's physical and
virtual dimensions, and its colour depth (bits per pixel). Once all the
parameters are set, we can ask the GPU for a framebuffer, using the
\code{FB\_ALLOCATE\_BUFFER} tag (defined in \code{mailbox.h} as
\code{0x00040001}). The returned values are a pointer to this framebuffer and its
size. 

\subsection{Booting on real hardware}
This is the first point at which the project has required testing on real
hardware, in order to verify that a framebuffer is being correctly requested and
supplied by the GPU. This required the kernel to be installed on an SD card and
for it to be run on the physical board of the Pi. It is now helpful to detail
the unique boot process of Pi, which makes this stage much easier.

\subsubsection{The boot process of the Raspberry Pi}
The boot process relies on closed-source proprietary code programmed into the
SoC processor \cite{Firmware} which cannot be modified. Importantly, the ARM CPU
is not the main CPU - it is a coprocessor to the VideoCore GPU. Upon powerup,
the ARM CPU is halted and the GPU is run. The firmware then loads the bootloader
from ROM to the L2 cache and executes it.  This first stage bootloader mounts
the FAT32 boot partition on the SD card so that the second stage bootloader may
be accessed.  This is its only responsibility, to load `bootcode.bin`. The first
stage bootloader is programmed into the SoC itself during manufacture and cannot
be reprogrammed by the user.  Next, the second stage bootloader (`bootcode.bin`)
then retrieves the GPU firmware from the SD card, programs the firmware, then
starts the GPU. The GPU firmware (`start.elf`) is loaded, and allows the GPU to
start up the CPU. An additional file `fixup.dat` is used to configure the SDRAM
partition between the GPU and CPU.  Here the kernel image is loaded, the CPU is
released from reset, and control is transferred to it to execute the kernel.

After the operating system is loaded, the code on the GPU is not unloaded;
instead, it runs its own simple operating system, called Video Core Operating
System (VCOS). The kernel can then use this to communicate with the services it
provides (e.g. providing a framebuffer, as above) using the Mailbox Peripheral
and interrupts (the GPU is able to produce ARM interrupts). The GPU is not only
in charge of graphical functions - it also controls clocks and audio, for
example. In this way the GPU firmware is similar to a normal PC's BIOS (Basic
Input/Output System) \cite{Boot1, Boot2}.

\subsubsection{Loading using Raspbian}
To install the project's kernel onto an SD card, we can simply install an
official operating system on it, such as Raspbian \cite{Raspbian}, and replace
\code{kernel7.img} with that produced by the Makefile (and renaming it to
\code{kernel7.img}). Now, when the bootloader would look to load Raspbian's
kernel image, it will load ours instead.

\subsection{Issues and debugging on real hardware}

% overview of work so far, including
%   technical content - what work have I done, meaningful summary of significant
%   aspects
%   progress - review progress against timetable. If unexpected delays, how have
%   they been dealt with?

\section{Project management}
\subsection{Development}
\subsection{Testing}
% How have I managed the project so far - may use formal methodology (e.g.
% management of code versions), and can refer to less formal ways of keeping on
% track, e.g. regular meetings with supervisor

\section{Next steps}
% outline plans for next term and any alterations to original ideas
% updated timetable with as much detail as possible

\section{Reflection}
% reflection and appraisal - assessment on how thing shave gone so far. Any
% lessons learned to make future progress smoother?

\section{Ethical consent}
% state that I have considered it, but not needed

\bibliography{bibliography}

\appendix

% include project specification as part of appendices
\includepdf[pages=-]{../specification/specification.pdf}

\end{document}
